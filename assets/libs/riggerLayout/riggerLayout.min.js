/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* 错误名字符串定义
*/
var riggerLayout;
(function (riggerLayout) {
    var ErrorStrings = (function () {
        function ErrorStrings() {
        }
        /**
         * 未实现，表示某个接口未实现
         */
        ErrorStrings.NotImplemented = "Not_Implemented";
        /**
         * 无效的布局规范
         */
        ErrorStrings.InvalidLayoutSpec = "Invalid_Layout_Spec";
        return ErrorStrings;
    }());
    riggerLayout.ErrorStrings = ErrorStrings;
})(riggerLayout || (riggerLayout = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* 全局设定
*/
var riggerLayout;
(function (riggerLayout) {
    var GlobalSettings = (function () {
        function GlobalSettings() {
        }
        return GlobalSettings;
    }());
    riggerLayout.GlobalSettings = GlobalSettings;
})(riggerLayout || (riggerLayout = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
 * 布局项，最终被真正布局的项
 */
var riggerLayout;
(function (riggerLayout) {
    var LayoutItem = (function () {
        // offSet(dx:number, dy:number):void{
        // 	this.x += dx;
        // 	this.y += dy;
        // }
        // protected graphic: Laya.Sprite;
        function LayoutItem(item) {
            // this.graphic = new Laya.Sprite();
            this.drawColor = "blue";
            this.mScaleX = 1;
            this.mScaleY = 1;
            // public offset(dx:number, dy:number):void{
            // 	this.rectangle.offset(dx, dy);
            // 	this.offsetX = dx;
            // 	this.offsetY = dy;
            // }
            this.offsetX = 0;
            // public get offsetX():number{
            // 	return this.mOffsetX;
            // }
            this.offsetY = 0;
            // if (Laya.stage) {
            // 	Laya.stage.addChildAt(this.graphic, 0);
            // }
            this.item = item;
            this.mapItem();
            this.initInfos();
            // if (Laya.stage) {
            // this.draw();
            // }
        }
        Object.defineProperty(LayoutItem.prototype, "x", {
            get: function () {
                return this.rectangle.x;
            },
            set: function (v) {
                if (v !== this.rectangle.x) {
                    this.rectangle.x = v;
                    // this.itemX = this.mapRectangleX();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutItem.prototype, "y", {
            get: function () {
                return this.rectangle.y;
            },
            set: function (v) {
                if (v !== this.rectangle.y) {
                    this.rectangle.y = v;
                    // this.itemY = this.mapRectangleY();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutItem.prototype, "scaleX", {
            get: function () {
                return this.mScaleX;
            },
            set: function (v) {
                if (v !== this.mScaleX) {
                    var old = this.rectangle.width / this.mScaleX;
                    this.rectangle.width = old * v;
                    this.mScaleX = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutItem.prototype, "scaleY", {
            get: function () {
                return this.mScaleY;
            },
            set: function (v) {
                if (v !== this.mScaleY) {
                    var old = this.rectangle.height / this.mScaleY;
                    this.rectangle.height = old * v;
                    this.mScaleY = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        LayoutItem.prototype.compareItem = function (item) {
            return item === this.item;
        };
        LayoutItem.prototype.setPos = function (x, y) {
            this.x = x;
            this.y = y;
        };
        LayoutItem.prototype.setScale = function (x, y) {
            if (x === this.mScaleX && y === this.mScaleY)
                return;
            var oldX = this.rectangle.width / this.mScaleX;
            var oldY = this.rectangle.height / this.mScaleY;
            this.rectangle.width = oldX * x;
            this.rectangle.height = oldY * y;
            this.mScaleX = x;
            this.mScaleY = y;
        };
        LayoutItem.prototype.dispose = function () {
            this.item = null;
            this.parent = null;
            this.rectangle.dispose();
        };
        /**
         * 两个比较自己和目标是否相等
         * 如果目标是LayoutItem,则比较二者引用是否相同
         * 如果目标非LayoutITem或其子类，则将目标和this.item的引用相比较
         * @param item
         */
        LayoutItem.prototype.equal = function (item) {
            if (item instanceof LayoutItem) {
                return this === item;
            }
            else {
                return this.item === item;
            }
        };
        LayoutItem.prototype.draw = function () {
            // this.graphic.graphics.clear();
            // console.log(`draw item rect, x:${this.rectangle.x}, y:${this.rectangle.y}, width:${this.rectangle.width}, height:${this.rectangle.height}`);
            // this.graphic.graphics.drawRect(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height, this.drawColor);
        };
        LayoutItem.prototype.setX = function (x) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        LayoutItem.prototype.setY = function (y) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        LayoutItem.prototype.setWidth = function (w) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        LayoutItem.prototype.setHeight = function (h) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        LayoutItem.prototype.setScaleX = function (sx) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        LayoutItem.prototype.setScaleY = function (sy) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        /**
         * 是否相同（本身或其持有的显示对象相同）
         * @param item
         */
        LayoutItem.prototype.isSame = function (item) {
            return item === this || this.item === item;
        };
        /**
         * 测试显示矩形范围
         */
        LayoutItem.prototype.measure = function () {
            this.mapItem();
        };
        LayoutItem.prototype.initInfos = function () {
            if (!this.item)
                return;
            this.initX = this.itemX;
            this.initY = this.itemY;
            this.initWidth = this.itemWidth;
            this.initHeight = this.itemHeight;
            this.initScaleX = this.itemScaleX;
            this.initScaleY = this.itemScaleY;
        };
        /**
         * 将显示项映射到矩形
         */
        LayoutItem.prototype.mapItem = function () {
            if (!this.rectangle) {
                this.rectangle = riggerLayout.Rectangle.createInstance();
                this.rectangle.setEmpty();
            }
            if (!this.item) {
                this.rectangle.setEmpty();
                return;
            }
            this.rectangle.x = this.mapItemX();
            this.rectangle.y = this.mapItemY();
            this.rectangle.width = this.mapItemWidth();
            this.rectangle.height = this.mapItemHeight();
        };
        /**
         * 将矩形的设置映射到实际显示对象上
         */
        LayoutItem.prototype.mapRectangle = function () {
            if (!this.rectangle)
                return;
            if (!this.item)
                return;
            this.itemScaleX = this.mapRectangleWidth();
            this.itemScaleY = this.mapRectangleHeight();
            this.itemX = this.mapRectangleX();
            this.itemY = this.mapRectangleY();
            // this.draw();
        };
        /**
         * 通过X，pivotX, scaleX的关系计算出其映射到矩形上后的X坐标
         */
        LayoutItem.prototype.mapItemX = function () {
            return (this.itemX - this.itemPivotX) + this.itemPivotX * (1 - this.itemScaleX);
        };
        LayoutItem.prototype.mapRectangleX = function () {
            return this.rectangle.x - this.itemPivotX * (1 - this.itemScaleX) + this.itemPivotX;
        };
        /**
         * 通过Y，pivotY, scaleY的关系计算出其映射到矩形上后的Y坐标
         *
         */
        LayoutItem.prototype.mapItemY = function () {
            return (this.itemY - this.itemPivotY) + this.itemPivotY * (1 - this.itemScaleY);
        };
        LayoutItem.prototype.mapRectangleY = function () {
            return this.rectangle.y - this.itemPivotY * (1 - this.itemScaleY) + this.itemPivotY;
        };
        LayoutItem.prototype.mapItemWidth = function () {
            return this.rectangle.width = this.itemWidth * this.itemScaleX;
        };
        LayoutItem.prototype.mapRectangleWidth = function () {
            return this.rectangle.width / this.itemWidth;
        };
        LayoutItem.prototype.mapItemHeight = function () {
            return this.rectangle.height = this.itemHeight * this.itemScaleY;
        };
        LayoutItem.prototype.mapRectangleHeight = function () {
            return this.rectangle.height / this.itemHeight;
        };
        return LayoutItem;
    }());
    riggerLayout.LayoutItem = LayoutItem;
})(riggerLayout || (riggerLayout = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* 自动布局容器基类
*/
var riggerLayout;
(function (riggerLayout) {
    var Group = (function (_super) {
        __extends(Group, _super);
        function Group(item) {
            var _this = _super.call(this, null) || this;
            /**
             * 当子对象为时是否释放
             */
            _this.doNotDestroy = false;
            _this.mitemX = 0;
            _this.mItemY = 0;
            _this.mItemWidth = 0;
            _this.mItemHeight = 0;
            _this.mItemScaleX = 1;
            _this.mItemScaleY = 1;
            _this.mItemPivotX = 0;
            _this.mItemPivotY = 0;
            _this.measuredWidth = 0;
            _this.measuredHeight = 0;
            if (item)
                _this.addChild(item);
            return _this;
        }
        Object.defineProperty(Group.prototype, "left", {
            get: function () {
                return this.mLeft;
            },
            /**
             * 距父容器左边距离
             * 格式:数字 -> 50, 字符串 -> "50%" | "50" | LayoutSpec | LayoutSpec[]
             */
            set: function (v) {
                this.mLeft = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "bottom", {
            get: function () {
                return this.mBottom;
            },
            /**
             * 距父级容器底部距离
             * 格式:数字 -> 50, 字符串 -> "50%" | "50" | LayoutSpec | LayoutSpec[]
             */
            set: function (v) {
                this.mBottom = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "right", {
            get: function () {
                return this.mRight;
            },
            /**
             * 距父级容器右边的距离
             * 格式:数字 -> 50, 字符串 -> "50%" | "50" | LayoutSpec | LayoutSpec[]
             */
            set: function (v) {
                this.mRight = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "top", {
            get: function () {
                return this.mTop;
            },
            /**
             * 距父级窗口顶部的距离
             * 格式:数字 -> 50, 字符串 -> "50%" | "50" | LayoutSpec | LayoutSpec[]
             */
            set: function (v) {
                this.mTop = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "width", {
            get: function () {
                return this.mWidth;
            },
            /**
             * 宽
             * 格式:数字 -> 50, 字符串 -> "50%" | "50" | LayoutSpec | LayoutSpec[]
             */
            set: function (v) {
                this.mWidth = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "height", {
            get: function () {
                return this.mHeight;
            },
            /**
             * 高
             * 格式:数字 -> 50, 字符串 -> "50%" | "50" | LayoutSpec | LayoutSpec[]
             */
            set: function (v) {
                this.mHeight = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "horizontalCenter", {
            get: function () {
                return this.mHorizontalCenter;
            },
            /**
             * 在父级容器中距离X轴中心的位置
             * 格式:数字 -> 50, 字符串 -> "50%" | "50" | LayoutSpec | LayoutSpec[]
             */
            set: function (v) {
                this.mHorizontalCenter = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "verticalCenter", {
            get: function () {
                return this.mVerticalCenter;
            },
            /**
             * 在父级容器中距离Y轴中心的位置
             */
            set: function (v) {
                this.mVerticalCenter = this.adaptLayoutSpec(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "numElements", {
            /**
             * 子项数量
             */
            get: function () {
                if (this.elementsContent)
                    return this.elementsContent.length;
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 将不同格式的布局规范适配成统一格式
         */
        Group.prototype.adaptLayoutSpec = function (v) {
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return null;
            if (riggerLayout.Utils.isString(v) && riggerLayout.Utils.isNullOrEmpty(v)) {
                return null;
            }
            if (riggerLayout.Utils.isString(v) || riggerLayout.Utils.isNumber(v)) {
                return riggerLayout.LayoutSpec.create(null, null, v);
            }
            return v;
        };
        Object.defineProperty(Group.prototype, "layout", {
            get: function () {
                if (!this.mLayout)
                    this.layout = new riggerLayout.LayoutBase();
                return this.mLayout;
            },
            set: function (v) {
                if (this.mLayout)
                    this.mLayout.dispose();
                this.mLayout = v;
                this.mLayout.target = this;
                this.mLayout.measure();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "x", {
            get: function () {
                return this.rectangle.x;
            },
            set: function (v) {
                if (v !== this.rectangle.x) {
                    this.rectangle.x = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "y", {
            get: function () {
                return this.rectangle.y;
            },
            set: function (v) {
                if (v !== this.rectangle.y) {
                    this.rectangle.y = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "scaleX", {
            get: function () {
                return this.mScaleX;
            },
            set: function (v) {
                if (v !== this.mScaleX) {
                    this.setScale(v, this.mScaleY);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "scaleY", {
            get: function () {
                return this.mScaleY;
            },
            set: function (v) {
                if (v !== this.mScaleY) {
                    this.setScale(this.mScaleX, v);
                }
            },
            enumerable: true,
            configurable: true
        });
        Group.prototype.setScale = function (x, y) {
            this.scaleChildren(x, y);
            _super.prototype.setScale.call(this, x, y);
        };
        Group.prototype.setPos = function (x, y) {
            this.offsetChildren(x - this.x, y - this.y);
            this.x = x;
            this.y = y;
        };
        Object.defineProperty(Group.prototype, "itemX", {
            get: function () {
                return this.mitemX;
            },
            set: function (v) {
                this.mitemX = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "itemY", {
            get: function () {
                return this.mItemY;
            },
            set: function (v) {
                this.mItemY = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "itemWidth", {
            get: function () {
                return this.mItemWidth;
            },
            set: function (v) {
                this.mItemWidth = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "itemHeight", {
            get: function () {
                return this.mItemHeight;
            },
            set: function (v) {
                this.mItemHeight = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "itemScaleX", {
            get: function () {
                return this.mItemScaleX;
            },
            set: function (v) {
                this.mItemScaleX = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "itemScaleY", {
            get: function () {
                return this.mItemScaleY;
            },
            set: function (v) {
                this.mItemScaleY = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "itemPivotX", {
            get: function () {
                return this.mItemPivotX;
            },
            set: function (v) {
                this.mItemPivotX = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "itemPivotY", {
            get: function () {
                return this.mItemPivotY;
            },
            set: function (v) {
                this.mItemPivotY = v;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取一个布局元素子项
         * @param index
         */
        Group.prototype.getElementAt = function (index) {
            if (!this.elementsContent || this.elementsContent.length <= 0)
                return null;
            return this.elementsContent[index];
        };
        /**
         * 通过名字获取元素
         * @param name
         */
        Group.prototype.getElementByName = function (name) {
            var eles = this.elementsContent;
            var len = eles.length;
            for (var i = 0; i < len; ++i) {
                if (name === eles[i].name)
                    return eles[i];
            }
            return null;
        };
        /**
         * 设置测量结果
         * @param width
         * @param height
         */
        Group.prototype.setMeasuredSize = function (width, height) {
            this.measuredWidth = width;
            this.measuredHeight = height;
        };
        /**
         * 将一个显示对象添加到布局组
         * @param item
         */
        Group.prototype.addChild = function (item) {
            if (item instanceof riggerLayout.LayoutItem) {
                this.doAddChild(item);
            }
            else {
                this.doAddChild(new riggerLayout.GlobalSettings.realLayoutItemClass(item));
            }
            // 延迟
            this.onChildRectangleChange();
            // Laya.timer.callLater(this, this.onChildRectangleChange);
        };
        /**
         * 从所有子级中移除对象
         * @param item
         */
        Group.prototype.remove = function (item) {
            if (!item)
                return false;
            if (!this.elementsContent || this.numElements <= 0)
                return false;
            var ret = this.doRemove(item);
            if (this.numElements <= 0 && !this.doNotDestroy) {
                if (this.parent)
                    this.parent.remove(this);
            }
            return ret;
        };
        /**
         * 布局组中有子对象的矩形区域发生了变化
         */
        Group.prototype.onChildRectangleChange = function () {
            this.measure();
            var oldRect = riggerLayout.Rectangle.createInstance().copyFrom(this.rectangle);
            if (!oldRect.equal(this.rectangle) && this.parent && this.parent.numElements > 0) {
                this.parent.onChildRectangleChange();
            }
            else {
                this.updateLayout(false);
            }
        };
        /**
         * 更新布局
         * @param needMeasure
         */
        Group.prototype.updateLayout = function (needMeasure) {
            if (needMeasure === void 0) { needMeasure = true; }
            // 测量和个子元素当前矩形区域并合并生成Group的当前区域
            needMeasure && this.measure();
            this.beforeLayout(this.rectangle.x, this.rectangle.y, this.rectangle.width / this.scaleX, this.rectangle.height / this.scaleY);
            // 确定大小(根据当前父容器大小及本身当前矩形大小)
            this.decideRealSize();
            // 应用真实大小
            this.applyRealSize();
            // 缩放后，校正矩形区域
            this.measure(false);
            // 确定位置
            this.decideRealPos();
            // 应用真实位置
            this.applyRealPos();
            // this.offsetX = this.realX;
            // this.offsetY = this.realY;
            var len = this.numElements;
            // 更新子项（组）的适配与布局
            var child;
            for (var i = 0; i < len; ++i) {
                child = this.getElementAt(i);
                if (child instanceof Group) {
                    child.updateLayout(false);
                }
            }
            this.afterLayout(this.rectangle.x, this.rectangle.y, this.realWidth, this.realHeight);
            //将矩形数据映射至真实显示对象
            this.mapRectangle();
        };
        /**
         *
         */
        Group.prototype.updateChildrenLayout = function () {
            var len = this.numElements;
            // 更新子项（组）的适配与布局
            var child;
            for (var i = 0; i < len; ++i) {
                child = this.getElementAt(i);
                if (child instanceof Group) {
                    child.updateLayout(false);
                }
            }
        };
        /**
         * 更新子对象布局并使用生效
         */
        Group.prototype.updateAndApplyChildrenLayout = function () {
            this.updateChildrenLayout();
            this.mapRectangle();
        };
        /**
         * 测量显示矩形区域
         */
        Group.prototype.measure = function (ifChild) {
            if (ifChild === void 0) { ifChild = true; }
            if (!this.layout)
                return this.setMeasuredSize(0, 0);
            this.layout.measure(ifChild);
        };
        /**
         * 调整目标的元素的大小并定位这些元素
         *
         * @param x
         * @param y
         * @param unscaledWidth
         * @param unScaledHeight
         */
        Group.prototype.beforeLayout = function (x, y, unscaledWidth, unScaledHeight) {
            //基础布局是静态布局，不需要做任何操作，保持原位即可
            if (this.layout)
                this.layout.beforeLayout(x, y, unscaledWidth, unScaledHeight);
        };
        /**
         * 布局完成后再次调整布局
         *
         * @param x
         * @param y
         * @param realWidth
         * @param realHeight
         */
        Group.prototype.afterLayout = function (x, y, realWidth, realHeight) {
            this.layout && this.layout.afterLayout(x, y, realWidth, realHeight);
        };
        Group.prototype.dispose = function () {
            if (this.mLayout)
                this.mLayout.dispose();
            // 析构所有设置规范
            this.disposeLayoutSpec();
            // 析构所有子对象
            this.disposeChildren();
            // 释放矩形
            this.rectangle && this.rectangle.dispose();
            this.rectangle = null;
            // 释放布局类
            this.mLayout && this.mLayout.dispose();
            this.mLayout = null;
            // 父对象析构
            _super.prototype.dispose.call(this);
        };
        /**
         * 将自身的矩形映射到所有子项
         */
        Group.prototype.mapRectangle = function () {
            // 先
            var len = this.numElements;
            for (var i = 0; i < len; ++i) {
                this.getElementAt(i).mapRectangle();
            }
            // this.draw();
        };
        /**
         * 获取所在的适配层
         */
        Group.prototype.getLayer = function () {
            if (this instanceof riggerLayout.LayoutLayer)
                return this;
            if (!this.parent)
                return null;
            if (this.parent instanceof riggerLayout.LayoutLayer) {
                return this.parent;
            }
            else {
                return this.parent.getLayer();
            }
        };
        /**
         * 偏移子对象
         * @param dx
         * @param dy
         */
        Group.prototype.offsetChildren = function (dx, dy) {
            var len = this.numElements;
            var child;
            for (var i = 0; i < len; ++i) {
                child = this.getElementAt(i);
                child.rectangle.offset(dx, dy);
            }
        };
        /**
         * 缩放子对象
         * @param x
         * @param y
         */
        Group.prototype.scaleChildren = function (x, y) {
            var len = this.numElements;
            var child;
            for (var i = 0; i < len; ++i) {
                child = this.getElementAt(i);
                if (child instanceof Group) {
                    continue;
                }
                var oldX = (child.x - this.offsetX) / child.scaleX;
                var oldY = (child.y - this.offsetY) / child.scaleY;
                child.setScale(x, y);
                child.setPos(oldX * x, oldY * y);
            }
            // 更新自身矩形
            // this.measure(false);
        };
        /**
         * 绘制矩形区域，用于DEBUG
         */
        Group.prototype.draw = function () {
            // this.graphic.alpha = 0.5;
            // this.graphic.graphics.clear();
            // console.log(`group ${this.name} draw,x:${this.rectangle.x}, y:${this.rectangle.y}, width:${this.rectangle.width}, height:${this.rectangle.height}`);
            // this.graphic.graphics.drawRect(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height, "blue");
        };
        Group.prototype.decideRealSize = function () {
            if (this.parent) {
                this.decideRealWidth();
                this.decideRealHeight();
            }
            // 再确定子级的
            var len = this.numElements;
            var temp;
            for (var i = 0; i < len; ++i) {
                temp = this.getElementAt(i);
                if (temp instanceof Group) {
                    temp.decideRealSize();
                }
            }
        };
        Group.prototype.decideRealPos = function () {
            if (this.parent) {
                this.decideRealX();
                this.decideRealY();
            }
            // 再确定子级的
            var len = this.numElements;
            var temp;
            for (var i = 0; i < len; ++i) {
                temp = this.getElementAt(i);
                if (temp instanceof Group) {
                    temp.decideRealPos();
                }
            }
        };
        Group.prototype.decideRealX = function () {
            if (this.decideRealXByLeft())
                return;
            if (this.decideRealXByRight())
                return;
            if (this.decideRealXByCenter())
                return;
            this.realX = this.rectangle.x;
        };
        Group.prototype.decideRealY = function () {
            if (this.decideRealYByTop())
                return;
            if (this.decideRealYByBottom())
                return;
            if (this.decideRealYByCenter())
                return;
            this.realY = this.rectangle.y;
        };
        Group.prototype.decideRealXByRight = function () {
            if (riggerLayout.Utils.isNullOrUndefined(this.right))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var v = riggerLayout.LayoutSpec.calculateRealValue(this.right, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return false;
            // if(v.isRelativeDesign()){
            // 	// this.getLayer().designWidth - this.
            // 	// 修正比例
            // 	let pdw:number = this.getParentDesignWidth();
            // 	let dw:number = this.getDesignWidth();
            // 	this.rectangle.x;
            // }
            var r = v.calculateValue(parentWidth);
            this.realX = parentWidth - this.realWidth - r + this.parent.realX;
            return true;
        };
        Group.prototype.getDesignWidth = function () {
            return this.rectangle.width / this.mScaleX;
        };
        Group.prototype.getDesignHeight = function () {
            return this.rectangle.height / this.mScaleY;
        };
        Group.prototype.getParentDesignWidth = function () {
            if (!this.parent)
                return null;
            if (this.parent instanceof riggerLayout.LayoutLayer) {
                return this.parent.designWidth;
            }
            return this.parent.rectangle.width / this.parent.mScaleX;
        };
        Group.prototype.getParentDesignHeight = function () {
            if (!this.parent)
                return null;
            if (this.parent instanceof riggerLayout.LayoutLayer) {
                return this.parent.designHeight;
            }
            return this.getParentRealHeight() / this.parent.mScaleY;
        };
        Group.prototype.decideRealXByLeft = function () {
            if (riggerLayout.Utils.isNullOrUndefined(this.left))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var v = riggerLayout.LayoutSpec.calculateRealValue(this.left, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return false;
            var x = v.calculateValue(parentWidth);
            this.realX = this.parent.realX + x;
            return true;
        };
        Group.prototype.decideRealXByCenter = function () {
            if (riggerLayout.Utils.isNullOrUndefined(this.horizontalCenter))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var v = riggerLayout.LayoutSpec.calculateRealValue(this.horizontalCenter, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return false;
            var c = v.calculateValue(parentWidth);
            this.realX = c + this.parent.realX + (parentWidth - this.realWidth) * 0.5;
            return true;
        };
        Group.prototype.decideRealYByTop = function () {
            if (riggerLayout.Utils.isNullOrUndefined(this.top))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var v = riggerLayout.LayoutSpec.calculateRealValue(this.top, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return false;
            var top = v.calculateValue(parentHeight);
            this.realY = this.parent.realY + top;
            return true;
        };
        Group.prototype.decideRealYByBottom = function () {
            if (riggerLayout.Utils.isNullOrUndefined(this.bottom))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var v = riggerLayout.LayoutSpec.calculateRealValue(this.bottom, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return false;
            var bottom = v.calculateValue(parentHeight);
            this.realY = parentHeight - this.realHeight - bottom + this.parent.realY;
            return true;
        };
        Group.prototype.decideRealYByCenter = function () {
            if (riggerLayout.Utils.isNullOrUndefined(this.verticalCenter))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var v = riggerLayout.LayoutSpec.calculateRealValue(this.verticalCenter, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return false;
            var c = v.calculateValue(parentHeight);
            this.realY = c + this.parent.realY + (parentHeight - this.realHeight) * 0.5;
            return true;
        };
        Group.prototype.applyRealSize = function () {
            var oldWidth = this.rectangle.width / this.mScaleX;
            var oldHeight = this.rectangle.height / this.mScaleY;
            var scaleX;
            var scaleY;
            // 如果宽，高都未设定，则不缩放
            if (riggerLayout.Utils.isNullOrUndefined(this.realWidth) && riggerLayout.Utils.isNullOrUndefined(this.realHeight)) {
                scaleX = this.mScaleX;
                scaleY = this.mScaleY;
            }
            else if (riggerLayout.Utils.isNullOrUndefined(this.realWidth)) {
                scaleX = scaleY = this.realHeight / oldHeight;
                this.realWidth = oldWidth * scaleX;
            }
            else if (riggerLayout.Utils.isNullOrUndefined(this.realHeight)) {
                scaleX = scaleY = this.realWidth / oldWidth;
                this.realHeight = oldHeight * scaleY;
            }
            else {
                scaleX = this.realWidth / oldWidth;
                scaleY = this.realHeight / oldHeight;
            }
            this.setScale(scaleX, scaleY);
        };
        Group.prototype.applyRealPos = function () {
            this.setPos(riggerLayout.Utils.isNullOrUndefined(this.realX) ? this.rectangle.x : this.realX, riggerLayout.Utils.isNullOrUndefined(this.realY) ? this.rectangle.y : this.realY);
        };
        Group.prototype.doRemove = function (item) {
            var len = this.numElements;
            var children = this.elementsContent;
            var ret = false;
            var temp;
            var newChildiren = [];
            // 递归移除
            for (var i = 0; i < len; ++i) {
                temp = children[i];
                if (temp.equal(item)) {
                    temp.dispose();
                    ret = true;
                }
                else {
                    // newChildiren.push(temp);
                    if (temp instanceof Group) {
                        if (temp.remove(item)) {
                            if (temp.numElements > 0 || temp.doNotDestroy) {
                                newChildiren.push(temp);
                            }
                            ret = true;
                        }
                    }
                }
            }
            this.elementsContent = newChildiren;
            return ret;
        };
        Group.prototype.doAddChild = function (item) {
            if (!this.elementsContent)
                this.elementsContent = [];
            var idx = this.elementsContent.indexOf(item);
            if (idx >= 0)
                return;
            item.parent = this;
            this.elementsContent.push(item);
        };
        /**
         * 更新Group的最终真实宽度
         * 1. 如果未规定则取初始值（加入时的值)
         * 2. 如果同时填写了left与right,则优先取left与right
         * 3.
         * @param parentWidth
         */
        Group.prototype.decideRealWidth = function () {
            if (!this.parent)
                return;
            // 先看left和Right是否会影响宽
            if (this.decideWidthByLeftAndRight())
                return;
            // 根据宽的类型确定真实宽
            if (riggerLayout.Utils.isNullOrUndefined(this.width)) {
                this.realWidth = riggerLayout.Utils.isNullOrUndefined(this.height) ? this.rectangle.width : null;
                return;
            }
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var widthValue = riggerLayout.LayoutSpec.calculateRealValue(this.width, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(widthValue)) {
                this.realWidth = riggerLayout.Utils.isNullOrUndefined(this.height) ? this.rectangle.width : null;
                return;
            }
            if (widthValue.isRelativeDesign()) {
                var oldWidth = this.rectangle.width / this.mScaleX;
            }
            else {
                this.realWidth = widthValue.calculateValue(parentWidth);
            }
        };
        Group.prototype.decideRealHeight = function () {
            if (!this.parent)
                return;
            // 检查top与bottom是否会影响高
            if (this.decideHeightByTopAndBottom())
                return;
            // 根据高的类型确定真实高
            if (riggerLayout.Utils.isNullOrUndefined(this.height)) {
                this.realHeight = riggerLayout.Utils.isNullOrUndefined(this.width) ? this.rectangle.height : null;
                return;
            }
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var heightValue = riggerLayout.LayoutSpec.calculateRealValue(this.height, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(heightValue)) {
                this.realHeight = riggerLayout.Utils.isNullOrUndefined(this.width) ? this.rectangle.height : null;
                return;
            }
            this.realHeight = heightValue.calculateValue(parentHeight);
        };
        Group.prototype.decideHeightByTopAndBottom = function () {
            if (!(riggerLayout.Utils.isLayoutInputValid(this.top) && riggerLayout.Utils.isLayoutInputValid(this.bottom)))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var topValue = riggerLayout.LayoutSpec.calculateRealValue(this.top, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(topValue))
                return false;
            var bottomValue = riggerLayout.LayoutSpec.calculateRealValue(this.bottom, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(bottomValue))
                return false;
            var realTop = topValue.calculateValue(parentHeight);
            var realBottom = bottomValue.calculateValue(parentHeight);
            this.realHeight = parentHeight - realTop - realBottom;
            return true;
        };
        /**
         * 根据左右边距确定宽：当同时规定了左右边距时，也意味着确定了宽
         */
        Group.prototype.decideWidthByLeftAndRight = function () {
            if (!(riggerLayout.Utils.isLayoutInputValid(this.left) && riggerLayout.Utils.isLayoutInputValid(this.right)))
                return false;
            var parentWidth = this.getParentRealWidth();
            var parentHeight = this.getParentRealHeight();
            var leftValue = riggerLayout.LayoutSpec.calculateRealValue(this.left, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(leftValue))
                return false;
            var rightValue = riggerLayout.LayoutSpec.calculateRealValue(this.right, parentWidth, parentHeight);
            if (riggerLayout.Utils.isNullOrUndefined(rightValue))
                return false;
            var realLeft = leftValue.calculateValue(parentWidth);
            var realRight = rightValue.calculateValue(parentWidth);
            this.realWidth = parentWidth - realLeft - realRight;
            return true;
        };
        Group.prototype.getParentRealWidth = function () {
            return riggerLayout.Utils.isNullOrUndefined(this.parent.realWidth) ? this.parent.rectangle.width : this.parent.realWidth;
        };
        Group.prototype.getParentRealHeight = function () {
            return riggerLayout.Utils.isNullOrUndefined(this.parent.realHeight) ? this.parent.rectangle.height : this.parent.realHeight;
        };
        /**
         * 析构适配规范设置
         */
        Group.prototype.disposeLayoutSpec = function () {
            this.doDisposeLayoutSpec(this.top);
            this.top = null;
            this.doDisposeLayoutSpec(this.bottom);
            this.bottom = null;
            this.doDisposeLayoutSpec(this.left);
            this.left = null;
            this.doDisposeLayoutSpec(this.right);
            this.right = null;
            this.doDisposeLayoutSpec(this.horizontalCenter);
            this.horizontalCenter = null;
            this.doDisposeLayoutSpec(this.verticalCenter);
            this.verticalCenter = null;
        };
        Group.prototype.disposeChildren = function () {
            var children = this.elementsContent;
            if (!children)
                return;
            var len = children.length;
            for (var i = 0; i < len; ++i) {
                children[i].dispose();
            }
            this.elementsContent = null;
        };
        Group.prototype.doDisposeLayoutSpec = function (spec) {
            if (!spec)
                return;
            if (spec instanceof riggerLayout.LayoutSpec) {
                spec.dispose();
                return;
            }
            for (var i = 0; i < spec.length; ++i) {
                spec[i].dispose();
            }
        };
        return Group;
    }(riggerLayout.LayoutItem));
    riggerLayout.Group = Group;
})(riggerLayout || (riggerLayout = {}));



/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* name
*/
var riggerLayout;
(function (riggerLayout) {
    var LayoutBase = (function () {
        function LayoutBase() {
        }
        /**
         * 如果 useVirtualLayout 为 true，则当布局目标改变时，布局目标可以使用此方法来清除已缓存布局信息
         */
        LayoutBase.prototype.clearVirtualLayoutCache = function () {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        /**
         * 在已添加布局元素之后且在验证目标的大小和显示列表之前，由目标调用
         */
        LayoutBase.prototype.elementAdded = function (index) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        /**
         * 返回此 Group 中可见的元素的索引
         */
        LayoutBase.prototype.getElementIndicesInView = function () {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        /**
         * 设置一个典型元素的大小
         * @param width
         * @param height
         */
        LayoutBase.prototype.setTypicalSize = function (width, height) {
            throw new Error(riggerLayout.ErrorStrings.NotImplemented);
        };
        /**
         * 调整目标的元素的大小并定位这些元素
         *
         * @param x
         * @param y
         * @param unscaledWidth
         * @param unScaledHeight
         */
        LayoutBase.prototype.beforeLayout = function (x, y, unscaledWidth, unScaledHeight) {
            //基础布局是静态布局，不需要做任何操作，保持原位即可
            // throw new Error(ErrorStrings.NotImplemented);
        };
        /**
         * 布局完成后再次调整布局
         *
         * @param x
         * @param y
         * @param realWidth
         * @param realHeight
         */
        LayoutBase.prototype.afterLayout = function (x, y, unscaledWidth, unScaledHeight) {
            // 默认不做处理
        };
        /**
         * 基于目标的内容测量其默认大小
         */
        LayoutBase.prototype.measure = function (ifChild) {
            if (ifChild === void 0) { ifChild = true; }
            var len = this.target.numElements;
            var temp;
            // let initRectangle: Rectangle = this.target.rectangle ? this.target.rectangle : Rectangle.createInstance();
            var initRectangle = riggerLayout.Rectangle.createInstance();
            if (len > 0) {
                initRectangle.copyFrom(this.target.getElementAt(0).rectangle);
            }
            else {
                initRectangle.setEmpty();
                this.target.rectangle.copyFrom(initRectangle);
                return;
            }
            var item;
            // 测量目标组中所有元素
            for (var i = 0; i < len; ++i) {
                item = this.target.getElementAt(i);
                // 测量子对象				
                if (ifChild) {
                    item.measure();
                }
                // 如果子对象不是组，则并入子对象的矩形区域
                // 为什么不并入组的矩形，因为组的矩形大小，位置由其自己决定，而不必刚好被父对象包围
                if (!(item instanceof riggerLayout.Group)) {
                    temp = initRectangle.union(item.rectangle);
                    initRectangle.copyFrom(temp);
                    temp.recover();
                }
            }
            // 更新目标组的Rectangle
            this.target.rectangle.copyFrom(initRectangle);
            initRectangle.setEmpty();
            initRectangle.recover();
        };
        LayoutBase.prototype.dispose = function () {
            if (this.target)
                this.target = null;
        };
        return LayoutBase;
    }());
    riggerLayout.LayoutBase = LayoutBase;
})(riggerLayout || (riggerLayout = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* name
*/
var riggerLayout;
(function (riggerLayout) {
    var LayoutLayer = (function (_super) {
        __extends(LayoutLayer, _super);
        function LayoutLayer(container) {
            var _this = _super.call(this) || this;
            _this.topContainer = container;
            _this.initRectangle();
            _this.topContainer.onResize(_this, _this.onResize, null);
            _this.layout = new riggerLayout.LayoutBase();
            return _this;
        }
        Object.defineProperty(LayoutLayer.prototype, "designWidth", {
            get: function () {
                if (!this.topContainer)
                    return null;
                return this.topContainer.getDesignWidth();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutLayer.prototype, "designHeight", {
            get: function () {
                if (!this.topContainer)
                    return null;
                return this.topContainer.getDesignHeight();
            },
            enumerable: true,
            configurable: true
        });
        LayoutLayer.prototype.relateTop = function (item) {
            if (item instanceof riggerLayout.LayoutItem) {
                return item.itemY / this.designHeight * 100 + "%";
            }
            else {
                var temp = riggerLayout.GlobalSettings.realLayoutItemClass(item);
                return this.relateTop(temp);
            }
        };
        LayoutLayer.prototype.relateBottom = function (item) {
            if (item instanceof riggerLayout.LayoutItem) {
                return (this.designHeight - item.itemHeight - item.itemY) / this.designHeight * 100 + "%";
            }
            else {
                var temp = riggerLayout.GlobalSettings.realLayoutItemClass(item);
                return this.relateBottom(temp);
            }
        };
        LayoutLayer.prototype.relateLeft = function (item) {
            if (item instanceof riggerLayout.LayoutItem) {
                return (item.itemX) / this.designWidth * 100 + "%";
            }
            else {
                var temp = riggerLayout.GlobalSettings.realLayoutItemClass(item);
                return this.relateLeft(temp);
            }
        };
        LayoutLayer.prototype.relateRight = function (item) {
            if (item instanceof riggerLayout.LayoutItem) {
                return (this.designWidth - item.itemX - item.itemWidth) / this.designWidth * 100 + "%";
            }
            else {
                var temp = riggerLayout.GlobalSettings.realLayoutItemClass(item);
                return this.relateRight(temp);
            }
        };
        LayoutLayer.prototype.relateHorizontalCenter = function (item) {
            if (item instanceof riggerLayout.LayoutItem) {
                return (item.itemWidth / 2 + item.itemX - this.designWidth / 2) / this.designWidth * 100 + "%";
            }
            else {
                var temp = riggerLayout.GlobalSettings.realLayoutItemClass(item);
                return this.relateHorizontalCenter(temp);
            }
        };
        LayoutLayer.prototype.measure = function (ifChild) {
            if (ifChild === void 0) { ifChild = true; }
            _super.prototype.measure.call(this, ifChild);
            this.initRectangle();
        };
        LayoutLayer.prototype.initRectangle = function () {
            if (!this.rectangle)
                this.rectangle = riggerLayout.Rectangle.createInstance();
            this.rectangle.x = 0;
            this.rectangle.y = 0;
            this.rectangle.width = this.topContainer.getRealWidth();
            this.rectangle.height = this.topContainer.getRealHeight();
        };
        LayoutLayer.prototype.decideRealSize = function () {
            this.realWidth = this.topContainer.getRealWidth();
            this.realHeight = this.topContainer.getRealHeight();
            _super.prototype.decideRealSize.call(this);
        };
        LayoutLayer.prototype.decideRealPos = function () {
            this.realX = 0;
            this.realY = 0;
            _super.prototype.decideRealPos.call(this);
        };
        LayoutLayer.prototype.draw = function () {
            // this.graphic.alpha = 0.5;
            // this.graphic.graphics.clear();
            // console.log(`group ${this.name} draw,x:${this.rectangle.x}, y:${this.rectangle.y}, width:${this.rectangle.width}, height:${this.rectangle.height}`);
            // this.graphic.graphics.drawRect(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height, "red");
        };
        LayoutLayer.prototype.onResize = function () {
            this.updateLayout();
        };
        return LayoutLayer;
    }(riggerLayout.Group));
    riggerLayout.LayoutLayer = LayoutLayer;
})(riggerLayout || (riggerLayout = {}));

/**
* 布局规范类，用于设置布局参数
*/
var riggerLayout;
(function (riggerLayout) {
    var LayoutSpec = (function () {
        function LayoutSpec() {
            /**
             * 布局规范类型
             */
            this.specType = riggerLayout.LayoutSpecType.ScreenSize;
        }
        /**
         * 解析用户填写的值规范
         * @param v
         */
        LayoutSpec.parseValueSpecs = function (v) {
            if (riggerLayout.Utils.isNullOrUndefined(v))
                return [null, null];
            if (riggerLayout.Utils.isString(v)) {
                if (riggerLayout.Utils.isNullOrEmpty(v))
                    return [null, null];
                if (LayoutSpec.RelativeDesign === v) {
                    return [riggerLayout.ValueType.RelativeDesign, null];
                }
                var idx = v.indexOf("%");
                var type = void 0;
                if (idx >= 0) {
                    type = riggerLayout.ValueType.Relative;
                }
                else {
                    type = riggerLayout.ValueType.Absolute;
                }
                var num = void 0;
                num = parseFloat(v);
                if (num === NaN)
                    return [null, null];
                return [type, num];
            }
            else {
                return [riggerLayout.ValueType.Absolute, v];
            }
        };
        /**
         * 计算真实的布局设置值
         *
         * @param specOrSpecArray 布局规范或规范数组
         * @param realWidth 真实屏幕宽
         * @param realHeight 真实屏幕高
         * @param realRatio 真实屏幕宽高比
         */
        LayoutSpec.calculateRealValue = function (specOrSpecArray, realWidth, realHeight) {
            if (specOrSpecArray instanceof LayoutSpec) {
                return specOrSpecArray.calculateRealValue(realWidth, realHeight);
            }
            else {
                var len = specOrSpecArray.length;
                var value = null;
                for (var i = 0; i < len; ++i) {
                    value = specOrSpecArray[i].calculateRealValue(realWidth, realHeight);
                    if (riggerLayout.Utils.isNullOrUndefined(value)) {
                        continue;
                    }
                    return value;
                }
                return value;
            }
        };
        LayoutSpec.prototype.dispose = function () {
            this.thisObj && (this.thisObj = null);
            if (!riggerLayout.Utils.isNullOrUndefined(this.minRatioOrFunction))
                this.minRatioOrFunction = null;
            if (!riggerLayout.Utils.isNullOrUndefined(this.maxRatioOrArgs))
                this.maxRatioOrArgs = null;
            if (!riggerLayout.Utils.isNullOrUndefined(this.value))
                this.value = null;
            this.min = this.max = null;
        };
        /**
         * @param thisObj 自定义的条件判断函数的调用域
         * @param fun 自定义的条件判断函数
         * @param args 传入的参数值，同时框架会将判断发生时的真实屏幕宽，并附加在用户的参数列表尾部
         * @param limit 此条件下的限定值
         * @param min 最小值
         * @param max 最大值
         */
        LayoutSpec.createByCustom = function (thisObj, fun, args, value, min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            return this.createInstWithCustom(thisObj, fun, args, LayoutSpec.parseValueSpecs(value), LayoutSpec.parseValueSpecs(min), LayoutSpec.parseValueSpecs(max));
        };
        /**
         * 根据指定参数创建一个LayoutSpec实例
         * @param minRatio 最小屏幕宽高比, 如果是 -1 表示忽略
         * @param maxRatio 最大屏幕宽高比, 如果是 -1 表示忽略
         * @param limit 此条件下的限定值
         * @param min 最小值
         * @param max 最大值
         *
         */
        LayoutSpec.create = function (minRatio, maxRatio, value, min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            return this.createInstWithSizeCondition(minRatio, maxRatio, LayoutSpec.parseValueSpecs(value), LayoutSpec.parseValueSpecs(min), LayoutSpec.parseValueSpecs(max));
        };
        /**
         * 计算真实的布局参数
         * @param realWidth 真实屏幕宽
         * @param realHeight 真实屏幕高
         */
        LayoutSpec.prototype.calculateRealValue = function (realWidth, realHeight) {
            switch (this.specType) {
                case riggerLayout.LayoutSpecType.ScreenSize:
                    return this.calculateRealValueByScreenSize(realWidth, realHeight);
                case riggerLayout.LayoutSpecType.Custom:
                    return this.calculateRealValueByCustom(realWidth, realHeight);
                case riggerLayout.LayoutSpecType.None:
                    return null;
                default:
                    return null;
            }
        };
        LayoutSpec.prototype.calculateRealValueByScreenSize = function (realWidth, realHeight) {
            // 无限制条件
            if (this.isIgnored(this.maxRatioOrArgs) && this.isIgnored(this.minRatioOrFunction))
                return new riggerLayout.LayoutValue(this.value, this.min, this.max);
            var realRatio = realWidth / realHeight;
            // 忽略最小宽高比
            if (this.isIgnored(this.minRatioOrFunction) && realRatio <= this.maxRatioOrArgs)
                return new riggerLayout.LayoutValue(this.value, this.min, this.max);
            // 忽略最大宽高比
            if (this.isIgnored(this.maxRatioOrArgs) && realRatio >= this.minRatioOrFunction)
                return new riggerLayout.LayoutValue(this.value, this.min, this.max);
            // 刚好在区间内
            if (realRatio >= this.minRatioOrFunction && realRatio <= this.maxRatioOrArgs)
                return new riggerLayout.LayoutValue(this.value, this.min, this.max);
            // 不满足
            return null;
        };
        LayoutSpec.prototype.calculateRealValueByCustom = function (realWidth, realHeight) {
            var args = (Array(this.maxRatioOrArgs)).concat([realWidth, realHeight]);
            if (this.minRatioOrFunction.apply(this.thisObj, args)) {
                return new riggerLayout.LayoutValue(this.value, this.min, this.max);
            }
            return null;
        };
        /**
         * 是否需要忽略
         * @param v
         */
        LayoutSpec.prototype.isIgnored = function (v) {
            return riggerLayout.Utils.isNullOrUndefined(v) || v < 0;
        };
        /**
         * 根据最大与最小限制计算最终值
         * @param parentWidth
         * @param parentHeight
         */
        // private calculateFinalValue(parentWidth:number, parentHeight:number): [ValueType, number] {
        // }
        /**
         * 以屏幕尺寸为条件创建一个实例
         * @param minRatio 最小屏幕宽高比
         * @param maxRatio 最大屏幕宽高比
         * @param limit 此条件下的限定值
         */
        LayoutSpec.createInstWithSizeCondition = function (minRatio, maxRatio, limit, min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            var inst = new LayoutSpec();
            inst.specType = riggerLayout.LayoutSpecType.ScreenSize;
            inst.minRatioOrFunction = minRatio;
            inst.maxRatioOrArgs = maxRatio;
            inst.value = limit;
            inst.min = min;
            inst.max = max;
            return inst;
        };
        /**
         * 以自定义条件创建一个实例
         * @param fun
         * @param args
         * @param limit
         */
        LayoutSpec.createInstWithCustom = function (thisObj, fun, args, limit, min, max) {
            var inst = new LayoutSpec();
            inst.thisObj = thisObj;
            inst.specType = riggerLayout.LayoutSpecType.Custom;
            inst.minRatioOrFunction = fun;
            inst.maxRatioOrArgs = args || [];
            inst.value = limit;
            inst.min = min;
            inst.max = max;
            return inst;
        };
        /**
         * 相对设计值进行缩放的标签
         */
        LayoutSpec.RelativeDesign = "d%";
        return LayoutSpec;
    }());
    riggerLayout.LayoutSpec = LayoutSpec;
})(riggerLayout || (riggerLayout = {}));

/**
* 布局规范的类型
*/
var riggerLayout;
(function (riggerLayout) {
    var LayoutSpecType;
    (function (LayoutSpecType) {
        LayoutSpecType[LayoutSpecType["None"] = 0] = "None";
        // 以屏幕尺寸为条件
        LayoutSpecType[LayoutSpecType["ScreenSize"] = 1] = "ScreenSize";
        // 自定义条件
        LayoutSpecType[LayoutSpecType["Custom"] = 2] = "Custom";
    })(LayoutSpecType = riggerLayout.LayoutSpecType || (riggerLayout.LayoutSpecType = {}));
})(riggerLayout || (riggerLayout = {}));

/**
* 适配值
*/
var riggerLayout;
(function (riggerLayout) {
    var LayoutValue = (function () {
        function LayoutValue(value, min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            /**
             * 值
             */
            this.value = null;
            /**
             * 最小值
             */
            this.min = null;
            /**
             * 最大值
             */
            this.max = null;
            this.value = value;
            this.min = min;
            this.max = max;
        }
        /**
         * 是否相对设计尺寸
         */
        LayoutValue.prototype.isRelativeDesign = function () {
            return this.value[0] === riggerLayout.ValueType.RelativeDesign;
        };
        /**
         * 计算最终值
         * @param refValue
         */
        LayoutValue.prototype.calculateValue = function (refValue) {
            var _a = this.value, valueT = _a[0], valueV = _a[1];
            var tempValue = valueT === riggerLayout.ValueType.Absolute ? valueV : refValue * valueV * 0.01;
            // 根据最小和最大值算出结果
            tempValue = this.calculateWithMin(refValue, tempValue);
            return this.calculateWithMax(refValue, tempValue);
        };
        /**
         *
         * @param refvalue 参考值
         * @param value 当前值
         */
        LayoutValue.prototype.calculateWithMin = function (refvalue, value) {
            var min = this.min;
            if (riggerLayout.Utils.isNullOrUndefined(min) || riggerLayout.Utils.isNullOrUndefined(min[0]) || riggerLayout.Utils.isNullOrUndefined(min[1]))
                return value;
            var minType = min[0], minValue = min[1];
            var realMin = minType === riggerLayout.ValueType.Absolute ? minValue : minValue * refvalue * 0.01;
            return value >= realMin ? value : realMin;
        };
        /**
         * 根据最大值
         * @param refValue
         * @param value
         */
        LayoutValue.prototype.calculateWithMax = function (refValue, value) {
            var max = this.max;
            if (riggerLayout.Utils.isNullOrUndefined(max) || riggerLayout.Utils.isNullOrUndefined(max[0]) || riggerLayout.Utils.isNullOrUndefined(max[1]))
                return value;
            var maxType = max[0], maxValue = max[1];
            var realMax = maxType === riggerLayout.ValueType.Absolute ? maxValue : maxValue * refValue * 0.01;
            return value <= realMax ? value : realMax;
        };
        return LayoutValue;
    }());
    riggerLayout.LayoutValue = LayoutValue;
})(riggerLayout || (riggerLayout = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* name
*/
var riggerLayout;
(function (riggerLayout) {
    var Point = (function () {
        function Point(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        Point.createInstance = function () {
            return riggerLayout.Pool.getItemByClass(Point.sign, Point);
        };
        Point.prototype.clone = function () {
            var ret = Point.createInstance();
            ret.x = this.x;
            ret.y = this.y;
            return ret;
        };
        Point.prototype.recover = function () {
            riggerLayout.Pool.recover(Point.sign, this);
        };
        Point.sign = "___POINT_SIGN";
        return Point;
    }());
    riggerLayout.Point = Point;
})(riggerLayout || (riggerLayout = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
 * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
 * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
 * 但是，right 和 bottom 属性与这四个属性是整体相关的。
 * 例如，如果更改 right 属性的值，则 width属性的值将发生变化；如果更改 bottom 属性，则 height 属性的值将发生变化
 */
var riggerLayout;
(function (riggerLayout) {
    var Rectangle = (function () {
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            /**
             * 矩形左上角的 x 坐标
             */
            this.mX = 0;
            /**
             * 矩形左上角的 y 坐标
             */
            this.mY = 0;
            /**
             * 矩形的宽度（以像素为单位）
             */
            this.mWidth = 0;
            /**
             * 高度，以像素为单位
             */
            this.mHeight = 0;
            this.mX = 0;
            this.mY = 0;
            this.mWidth = 0;
            this.mHeight = 0;
            this.topLeft = riggerLayout.Point.createInstance();
            this.bottomRight = riggerLayout.Point.createInstance();
            this.updateCorner();
        }
        Rectangle.createInstance = function () {
            return riggerLayout.Pool.getItemByClass(Rectangle.sign, Rectangle);
        };
        Object.defineProperty(Rectangle.prototype, "x", {
            get: function () {
                return this.mX;
            },
            set: function (v) {
                this.mX = v;
                this.updateCorner();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "y", {
            get: function () {
                return this.mY;
            },
            set: function (v) {
                this.mY = v;
                this.updateCorner();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "width", {
            get: function () {
                return this.mWidth;
            },
            set: function (v) {
                this.mWidth = v;
                this.updateCorner();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "height", {
            get: function () {
                return this.mHeight;
            },
            set: function (v) {
                this.mHeight = v;
                this.updateCorner();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "left", {
            /**
             * 矩形左上角的 x 坐标
             */
            get: function () {
                return this.topLeft.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "bottom", {
            /**
             * Y与height属性的和
             */
            get: function () {
                return this.y + this.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "right", {
            /**
             * x 和 width 属性的和
             */
            get: function () {
                return this.x + this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "top", {
            /**
             * 矩形左上角的 y 坐标
             */
            get: function () {
                return this.topLeft.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 判断两个矩形是否相等
         * @param rect
         */
        Rectangle.prototype.equal = function (rect) {
            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;
        };
        /**
         * 设置矩形的属性
         * @param x
         * @param y
         * @param width
         * @param height
         */
        Rectangle.prototype.setTo = function (x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        };
        Rectangle.prototype.isEmpty = function () {
            return this.x === 0 && this.y === 0 && this.width === 0 && this.height === 0;
        };
        Rectangle.prototype.setEmpty = function () {
            this.x = this.y = this.width = this.height = 0;
        };
        Rectangle.prototype.copyFrom = function (rect) {
            this.x = rect.x;
            this.y = rect.y;
            this.width = rect.width;
            this.height = rect.height;
            return this;
        };
        Rectangle.prototype.clone = function () {
            var rect = Rectangle.createInstance();
            rect.setTo(this.x, this.y, this.width, this.height);
            return rect;
        };
        Rectangle.prototype.offset = function (dx, dy) {
            this.x += dx;
            this.y += dy;
        };
        Rectangle.prototype.contains = function (x, y) {
            return x >= this.left && x <= this.right && y >= this.top && y <= this.bottom;
        };
        Rectangle.prototype.containsPoint = function (point) {
            return this.contains(point.x, point.y);
        };
        Rectangle.prototype.containsRect = function (rect) {
            return this.containsPoint(rect.topLeft) && this.containsPoint(rect.bottomRight);
        };
        /**
         * 合并两个矩形并形成一个新矩形(此操作不会改变原来的矩形)
         * @param toUnion
         */
        Rectangle.prototype.union = function (toUnion) {
            if (this.containsRect(toUnion))
                return this.clone();
            if (toUnion.containsRect(this)) {
                return toUnion.clone();
            }
            var ret = Rectangle.createInstance();
            ret.x = riggerLayout.Math.min(this.x, toUnion.x);
            ret.y = riggerLayout.Math.min(this.y, toUnion.y);
            var tempLeft = riggerLayout.Math.min(this.left, toUnion.left);
            var tempRight = riggerLayout.Math.max(this.right, toUnion.right);
            ret.width = tempRight - tempLeft;
            var tempTop = riggerLayout.Math.min(this.top, toUnion.top);
            var tempBottom = riggerLayout.Math.max(this.bottom, toUnion.bottom);
            ret.height = tempBottom - tempTop;
            return ret;
        };
        Rectangle.prototype.recover = function () {
            riggerLayout.Pool.recover(Rectangle.sign, this);
        };
        Rectangle.prototype.dispose = function () {
            this.bottomRight.recover();
            this.bottomRight = null;
            this.topLeft.recover();
            this.topLeft = null;
        };
        Rectangle.prototype.updateCorner = function () {
            this.topLeft.x = this.x;
            this.topLeft.y = this.y;
            this.bottomRight.x = this.x + this.width;
            this.bottomRight.y = this.y + this.height;
        };
        Rectangle.sign = "___Rectangle_";
        return Rectangle;
    }());
    riggerLayout.Rectangle = Rectangle;
})(riggerLayout || (riggerLayout = {}));

/**
* name
*/
var riggerLayout;
(function (riggerLayout) {
    var ValueType;
    (function (ValueType) {
        // 未检测到有效类型
        ValueType[ValueType["None"] = 0] = "None";
        /**
         * 绝对值
         */
        ValueType[ValueType["Absolute"] = 1] = "Absolute";
        /**
         * 相对值
         */
        ValueType[ValueType["Relative"] = 2] = "Relative";
        /**
         * 相对设计值
         */
        ValueType[ValueType["RelativeDesign"] = 3] = "RelativeDesign";
    })(ValueType = riggerLayout.ValueType || (riggerLayout.ValueType = {}));
})(riggerLayout || (riggerLayout = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* 数组工具箱
*/
var riggerLayout;
(function (riggerLayout) {
    var ArrayUtil = (function () {
        function ArrayUtil() {
        }
        /**
         * 在数组中查找指定元素的索引，如果未找到，则返回-1
         * @param arr
         * @param predFun
         */
        ArrayUtil.findIndex = function (arr, predFun) {
            if (!arr || arr.length <= 0)
                return -1;
            var len = arr.length;
            for (var i = 0; i < len; ++i) {
                if (predFun(arr[i], arr, i)) {
                    return i;
                }
            }
            return -1;
        };
        /**
         * 从数组中移除一个符合条件的元素，如果移除成功返回被移除元素的索引
         * 只移除第一个符合条件的元素
         * @param arr
         * @param predFun
         */
        ArrayUtil.remove = function (arr, predFun) {
            var idx = ArrayUtil.findIndex(arr, predFun);
            if (idx < 0)
                return idx;
            ArrayUtil.removeAt(arr, idx);
            return idx;
        };
        /**
         * 从数组中移除指定索引的元素
         * @param arr
         * @param idx
         */
        ArrayUtil.removeAt = function (arr, idx) {
            arr.splice(idx, 1);
            return arr;
        };
        return ArrayUtil;
    }());
    riggerLayout.ArrayUtil = ArrayUtil;
})(riggerLayout || (riggerLayout = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* 数学工具箱
*/
var riggerLayout;
(function (riggerLayout) {
    var Math = (function () {
        function Math() {
        }
        Math.max = function (ele1, ele2) {
            var objs = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                objs[_i - 2] = arguments[_i];
            }
            var max = ele1 >= ele2 ? ele1 : ele2;
            if (objs.length <= 0)
                return max;
            for (var i = 0; i < objs.length; ++i) {
                max = max >= objs[i] ? max : objs[i];
            }
            return max;
        };
        Math.min = function (ele1, ele2) {
            var objs = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                objs[_i - 2] = arguments[_i];
            }
            var min = ele1 <= ele2 ? ele1 : ele2;
            if (objs.length <= 0)
                return min;
            for (var i = 0; i < objs.length; ++i) {
                min = min <= objs[i] ? min : objs[i];
            }
            return min;
        };
        return Math;
    }());
    riggerLayout.Math = Math;
})(riggerLayout || (riggerLayout = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* name
*/
var riggerLayout;
(function (riggerLayout) {
    var Pool = (function () {
        function Pool() {
        }
        /**
         * 根据对象类型标识字符，获取对象池。
         * @param sign 对象类型标识字符。
         * @return 对象池。
         */
        Pool.getPoolBySign = function (sign) {
            return Pool.pools[sign];
        };
        /**
         * 清除对象池的对象。
         * @param sign 对象类型标识字符。
         */
        Pool.clearBySign = function (sign) {
            delete Pool.pools[sign];
        };
        /**
         * 将对象放到对应类型标识的对象池中。
         * @param sign 对象类型标识字符。
         * @param item 对象。
         */
        Pool.recover = function (sign, item) {
            var subPool = Pool.pools[sign];
            if (!subPool)
                subPool = Pool.pools[sign] = [];
            subPool.push(item);
        };
        /**
         * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
         * <p>当对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。</p>
         * @param sign 对象类型标识字符。
         * @param cls 用于创建该类型对象的类。
         * @return 此类型标识的一个对象。
         */
        Pool.getItemByClass = function (sign, cls) {
            var subPool = Pool.pools[sign];
            if (!subPool || subPool.length <= 0) {
                return new cls();
            }
            else {
                return subPool.pop();
            }
        };
        /**
         * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
         * <p>当对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。</p>
         * @param sign 对象类型标识字符。
         * @param createFun 用于创建该类型对象的方法。
         * @return 此类型标识的一个对象。
         */
        Pool.getItemByCreateFun = function (sign, createFun) {
            var subPool = Pool.pools[sign];
            if (!subPool || subPool.length <= 0) {
                return createFun();
            }
            else {
                return subPool.pop();
            }
        };
        /**
         * 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
         * @param sign 对象类型标识字符。
         * @return 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
         */
        Pool.getItem = function (sign) {
            var subPool = Pool.pools[sign];
            if (!subPool || subPool.length <= 0) {
                return null;
            }
            else {
                return subPool.pop();
            }
        };
        Pool.pools = {};
        return Pool;
    }());
    riggerLayout.Pool = Pool;
})(riggerLayout || (riggerLayout = {}));

/**
* name
*/
var riggerLayout;
(function (riggerLayout) {
    var Utils = (function () {
        function Utils() {
        }
        /**
         * 判断参数是否是一个字符串
         */
        Utils.isString = function (str) {
            return typeof str === "string";
        };
        /**
         * 判断参数是否是一个数字
         * @param num
         */
        Utils.isNumber = function (num) {
            return typeof num === "number";
        };
        /**
         * 判断是否是函数
         * @param fun
         */
        Utils.isFunction = function (fun) {
            return typeof fun === "function";
        };
        /**
         * 检查是否为空或未定义
         */
        Utils.isNullOrUndefined = function (obj) {
            return obj === null || obj === undefined;
        };
        /**
         * 字符串是否为空或空串
         */
        Utils.isNullOrEmpty = function (str) {
            return Utils.isNullOrUndefined(str) || str.length <= 0;
        };
        Utils.isLayoutInputValid = function (v) {
            if (Utils.isNumber(v)) {
                return true;
            }
            if (Utils.isString(v)) {
                return !Utils.isNullOrEmpty(v);
            }
            else {
                return !Utils.isNullOrUndefined(v);
            }
        };
        return Utils;
    }());
    riggerLayout.Utils = Utils;
})(riggerLayout || (riggerLayout = {}));
