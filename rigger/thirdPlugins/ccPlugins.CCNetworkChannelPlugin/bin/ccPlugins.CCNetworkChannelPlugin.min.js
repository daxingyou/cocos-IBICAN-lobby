var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ccPlugins;
(function (ccPlugins) {
    var CCNetworkChannelPlugin = /** @class */ (function (_super) {
        __extends(CCNetworkChannelPlugin, _super);
        function CCNetworkChannelPlugin() {
            var _this = this;
            rigger.service.NetworkService;
            _this = _super.call(this) || this;
            return _this;
        }
        /**
         * 插件开始时的回调
         * @param resultHandler
         * @param startupArgs
         */
        CCNetworkChannelPlugin.prototype.onStart = function (resultHandler, startupArgs) {
            resultHandler.success();
        };
        /**
         * 插件停止时的回调
         * @param resultHandler
         */
        CCNetworkChannelPlugin.prototype.onStop = function (resultHandler) {
            resultHandler.success();
        };
        /**
         * 插件重启时的回调
         * @param resultHandler
         */
        CCNetworkChannelPlugin.prototype.onRestart = function (resultHandler) {
            resultHandler.success();
        };
        /**
         * @extends rigger.utils.DecoratorUtil.makeExtendable()
         * @param {NetworkChannelSpec[]} channelInfo 将要创建的频道的描述符
         * @returns {INetworkChannel[]}
         */
        CCNetworkChannelPlugin.prototype.createChannels = function (channelInfo) {
            var ret = [];
            for (var i = 0; i < channelInfo.length; ++i) {
                switch (channelInfo[i].channelType) {
                    case rigger.service.NetworkChannelType.WEB_SOCKET:
                        ret.push(new ccPlugins.CCWebsocketNetworkChannel(channelInfo[i].channelName));
                        break;
                    default:
                        break;
                }
            }
            return ret;
        };
        return CCNetworkChannelPlugin;
    }(rigger.AbsServicePlugin));
    ccPlugins.CCNetworkChannelPlugin = CCNetworkChannelPlugin;
})(ccPlugins || (ccPlugins = {}));

var ccPlugins;
(function (ccPlugins) {
    var CCWebsocketNetworkChannel = /** @class */ (function () {
        function CCWebsocketNetworkChannel(channelName) {
            this.channelType = rigger.service.NetworkChannelType.WEB_SOCKET;
            this.socket = null;
            this.channelName = channelName;
        }
        /**
         * 获取频道名称
         */
        CCWebsocketNetworkChannel.prototype.getChannelName = function () {
            return this.channelName;
        };
        /**
         * 为频道建立连接
         * 如果当前频道处于非关闭状态（包括未初始化),则会发生错误
         * 连接开始前会注册各种事件(onopen,onerror,onclose)
         * @param ip ws://url 或 ws://url:port 或 wss://url等形式
         * @param port 端口，可以不填
         */
        CCWebsocketNetworkChannel.prototype.connect = function (ip, port) {
            // 如果已经存在连接，且未关闭,则抛错
            if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                throw new Error("A Channel is avtivated, and not closed, now state:" + this.socket.readyState);
            }
            // 新建连接
            var url = rigger.utils.Utils.isNullOrUndefined(port) ? ip : ip + ":" + port;
            this.socket = new WebSocket(url);
            this.socket.binaryType = "arraybuffer";
            this.listenSocket();
        };
        CCWebsocketNetworkChannel.prototype.isEngaged = function () {
            if (!this.socket)
                return false;
            return this.socket.readyState !== WebSocket.CLOSED;
        };
        /**
         * 通过频道发送数据
         * @param data
         * @throws new Error(`Socket is not ready to send, channel name:${this.channelName}`)
         */
        CCWebsocketNetworkChannel.prototype.send = function (data) {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                if (data instanceof rigger.utils.Byte) {
                    this.socket.send(data.buffer);
                }
                else {
                    this.socket.send(data);
                }
            }
            else {
                throw new Error("Socket is not ready to send, channel name:" + this.channelName);
            }
        };
        CCWebsocketNetworkChannel.prototype.close = function (code, reason) {
            // 检查连接状态
            if (!this.socket)
                return;
            if (this.socket.readyState === WebSocket.CLOSED || this.socket.readyState === WebSocket.CLOSING)
                return;
            this.socket.close(code, reason);
            // this.socket = null;
        };
        CCWebsocketNetworkChannel.prototype.onConnect = function (caller, method, args, once) {
            if (!this.openListener)
                this.openListener = new rigger.utils.ListenerManager();
            this.openListener.on(caller, method, args, once);
        };
        CCWebsocketNetworkChannel.prototype.offConnect = function (caller, method) {
            if (this.openListener) {
                this.openListener.off(caller, method);
            }
        };
        CCWebsocketNetworkChannel.prototype.onError = function (caller, method, args, once) {
            if (!this.errorListener)
                this.errorListener = new rigger.utils.ListenerManager();
            this.errorListener.on(caller, method, args, once);
        };
        CCWebsocketNetworkChannel.prototype.offError = function (caller, method) {
            if (this.errorListener) {
                this.errorListener.off(caller, method);
            }
        };
        CCWebsocketNetworkChannel.prototype.onClose = function (caller, method, args, once) {
            if (!this.closeListener) {
                this.closeListener = new rigger.utils.ListenerManager();
            }
            this.closeListener.on(caller, method, args, once);
        };
        CCWebsocketNetworkChannel.prototype.offClose = function (caller, method) {
            if (this.closeListener) {
                this.closeListener.off(caller, method);
            }
        };
        CCWebsocketNetworkChannel.prototype.onMessage = function (caller, method, args, once) {
            if (!this.messageListener) {
                this.messageListener = new rigger.utils.ListenerManager;
            }
            this.messageListener.on(caller, method, args, once);
        };
        CCWebsocketNetworkChannel.prototype.offMessage = function (caller, method) {
            if (this.messageListener) {
                this.messageListener.off(caller, method);
            }
        };
        CCWebsocketNetworkChannel.prototype.listenSocket = function () {
            if (this.socket) {
                var self_1 = this;
                this.socket.onopen = function () {
                    self_1.openListener && self_1.openListener.execute();
                };
                this.socket.onclose = function () {
                    try {
                        self_1.closeListener && self_1.closeListener.execute();
                    }
                    catch (error) {
                        // self.socket = null;
                    }
                    self_1.disposeListeners();
                    self_1.socket = null;
                };
                this.socket.onerror = function (event) {
                    self_1.errorListener && self_1.errorListener.execute(event);
                };
                this.socket.onmessage = function (event) {
                    self_1.messageListener && self_1.messageListener.execute(event.data);
                };
            }
        };
        CCWebsocketNetworkChannel.prototype.disposeListeners = function () {
            if (this.socket) {
                this.socket.onclose = this.socket.onopen = this.socket.onerror = this.socket.onmessage = null;
            }
            this.openListener && this.openListener.dispose();
            this.errorListener && this.errorListener.dispose();
            this.closeListener && this.closeListener.dispose();
            this.messageListener && this.messageListener.dispose();
        };
        return CCWebsocketNetworkChannel;
    }());
    ccPlugins.CCWebsocketNetworkChannel = CCWebsocketNetworkChannel;
})(ccPlugins || (ccPlugins = {}));
