var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
* 适用于Cocos creater的定时插件
*/
var ccPlugins;
(function (ccPlugins) {
    var CCTimerPluginCallbackSpec = (function () {
        function CCTimerPluginCallbackSpec() {
            this.handlers = [];
        }
        CCTimerPluginCallbackSpec.create = function (plugin, caller) {
            var inst = rigger.service.PoolService.getItemByClass(CCTimerPluginCallbackSpec.POOL_SIGN, CCTimerPluginCallbackSpec);
            inst.caller = caller;
            inst.parent = plugin;
            return inst;
        };
        CCTimerPluginCallbackSpec.prototype.recover = function () {
            this.dispose();
            rigger.service.PoolService.recover(CCTimerPluginCallbackSpec.POOL_SIGN, this);
        };
        CCTimerPluginCallbackSpec.prototype.removeAt = function (idx) {
            if (idx < this.handlers.length) {
                this.handlers = rigger.utils.Utils.removeAtFromArray(this.handlers, idx);
            }
            return this.handlers.length;
        };
        CCTimerPluginCallbackSpec.prototype.remove = function (handlerSpec) {
            var temp = [];
            this.handlers.forEach(function (element) {
                if (handlerSpec !== element) {
                    temp.push(element);
                }
            });
            this.handlers = temp;
            this.checkIfKeep();
        };
        CCTimerPluginCallbackSpec.prototype.checkIfKeep = function () {
            if (!this.handlers) {
                this.recover();
            }
            if (this.handlers.length <= 0) {
                this.recover();
            }
        };
        CCTimerPluginCallbackSpec.prototype.dispose = function () {
            for (var i = 0; i < this.handlers.length; ++i) {
                this.handlers[i].dispose(false);
            }
            this.handlers = [];
            this.caller = null;
            if (this.parent) {
                this.parent.remove(this);
                this.parent = null;
            }
        };
        CCTimerPluginCallbackSpec.POOL_SIGN = "_CCTIMER_PLUGIN_CALLBACK_SPEC_SIGN";
        return CCTimerPluginCallbackSpec;
    }());
    ccPlugins.CCTimerPluginCallbackSpec = CCTimerPluginCallbackSpec;
    var CCTimerPluginHandlerSpec = (function () {
        function CCTimerPluginHandlerSpec() {
        }
        CCTimerPluginHandlerSpec.create = function (callback, caller, method, args, restTimes) {
            if (restTimes === void 0) { restTimes = null; }
            var inst = rigger.service.PoolService.getItemByClass(CCTimerPluginHandlerSpec.POOL_SIGN, CCTimerPluginHandlerSpec);
            inst.init(callback, caller, method, args, restTimes);
            return inst;
        };
        CCTimerPluginHandlerSpec.prototype.recover = function () {
            this.dispose();
            rigger.service.PoolService.recover(CCTimerPluginHandlerSpec.POOL_SIGN, this);
        };
        CCTimerPluginHandlerSpec.prototype.execute = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.handler.runWith(args);
            if (!rigger.utils.Utils.isNullOrUndefined(this.restTimes)) {
                this.restTimes -= 1;
                if (this.restTimes <= 0) {
                    this.recover();
                }
            }
        };
        CCTimerPluginHandlerSpec.prototype.compare = function (mehtod) {
            return this.handler && this.handler.method === mehtod;
        };
        CCTimerPluginHandlerSpec.prototype.init = function (callback, caller, method, args, restTimes) {
            if (restTimes === void 0) { restTimes = null; }
            this.parent = caller;
            this.handler = rigger.RiggerHandler.create(caller.caller, method, args, false);
            this.callback = callback;
            this.restTimes = restTimes;
            // this.parent && this.parent.parent && this.parent.parent.schedule(callback, )
        };
        CCTimerPluginHandlerSpec.prototype.dispose = function (ifRemoveFromParent) {
            if (ifRemoveFromParent === void 0) { ifRemoveFromParent = true; }
            this.handler && this.handler.recover();
            this.handler = null;
            if (this.parent) {
                if (this.callback) {
                    this.parent.parent.unschedule(this.callback);
                }
                this.callback = null;
                if (ifRemoveFromParent) {
                    this.parent.remove(this);
                }
                this.parent = null;
            }
            this.restTimes = null;
        };
        CCTimerPluginHandlerSpec.POOL_SIGN = "_CCTIMER_PLUGIN_HANDLER_SPEC_SIGN";
        return CCTimerPluginHandlerSpec;
    }());
    ccPlugins.CCTimerPluginHandlerSpec = CCTimerPluginHandlerSpec;
    var CCTimerPlugin = (function (_super) {
        __extends(CCTimerPlugin, _super);
        function CCTimerPlugin() {
            var _this = _super.call(this) || this;
            _this.callbacks = [];
            return _this;
        }
        CCTimerPlugin.prototype.unschedule = function (callback) {
            this.applicationEntity && this.applicationEntity.unschedule(callback);
        };
        CCTimerPlugin.prototype.schedule = function (callback, interval, repeat, delay) {
            this.applicationEntity && this.applicationEntity.schedule(callback, interval, repeat, delay);
        };
        CCTimerPlugin.prototype.loop = function (delay, caller, method, args, coverBefore, jumpFrame) {
            this.addListener(delay, cc.macro.REPEAT_FOREVER, caller, method, args, coverBefore);
        };
        CCTimerPlugin.prototype.once = function (delay, caller, method, args, coverBefore) {
            this.addListener(delay, 0, caller, method, args, coverBefore);
        };
        CCTimerPlugin.prototype.clear = function (caller, method) {
            var _a = this.findCallback(caller, method), idx1 = _a[0], idx2 = _a[1];
            if (idx1 >= 0 && idx2 >= 0) {
                this.callbacks[idx1].handlers[idx2].recover();
            }
        };
        CCTimerPlugin.prototype.clearAll = function (caller) {
            var idx = rigger.utils.Utils.findIndexFromArray(this.callbacks, function (e) { return e.caller == caller; });
            if (idx >= 0) {
                this.callbacks[idx].recover();
            }
        };
        CCTimerPlugin.prototype.remove = function (callbackSpec) {
            var temp = [];
            for (var i = 0; i < this.callbacks.length; ++i) {
                if (this.callbacks[i] !== callbackSpec) {
                    temp.push(this.callbacks[i]);
                }
            }
            this.callbacks = temp;
        };
        /**
         * 插件开始时的回调
         * @param resultHandler
         * @param startupArgs
         */
        CCTimerPlugin.prototype.onStart = function (resultHandler, startupArgs) {
            this.applicationEntity = startupArgs["applictionEntity"];
            resultHandler.success();
        };
        /**
         * 插件停止时的回调
         * @param resultHandler
         */
        CCTimerPlugin.prototype.onStop = function (resultHandler) {
            resultHandler.success();
        };
        /**
         * 插件重启时的回调
         * @param resultHandler
         */
        CCTimerPlugin.prototype.onRestart = function (resultHandler) {
            resultHandler.success();
        };
        /**
         * 查找已经注册的回调， 如果找到则返回其索引元组
         * @param caller
         * @param method
         */
        CCTimerPlugin.prototype.findCallback = function (caller, method) {
            var len = this.callbacks.length;
            for (var i = 0; i < len; ++i) {
                if (this.callbacks[i].caller === caller) {
                    // 查找method
                    for (var j = 0; j < this.callbacks[i].handlers.length; ++j) {
                        if (method === this.callbacks[i].handlers[j].handler.method) {
                            return [i, j];
                        }
                    }
                    return [i, -1];
                }
            }
            return [-1, -1];
        };
        CCTimerPlugin.prototype.addNewHandler = function (delay, repeat, caller, method, args) {
            // 插入对应对象的callback
            var callbackSpec = this.initCallbackSpec(caller);
            var restTimes = null;
            if (repeat != cc.macro.REPEAT_FOREVER) {
                restTimes = repeat + 1;
            }
            var handlerSpec = CCTimerPluginHandlerSpec.create(function (dt) {
                handlerSpec.execute([dt]);
            }, callbackSpec, method, args, restTimes);
            callbackSpec.handlers.push(handlerSpec);
            // this.callbacks.push(callbackSpec);
            // 转换单位 
            delay = delay / 1000;
            // 增加调度
            this.applicationEntity.schedule(handlerSpec.callback, delay, repeat, delay);
        };
        CCTimerPlugin.prototype.initCallbackSpec = function (caller) {
            if (rigger.utils.Utils.isNumber(caller)) {
                return this.callbacks[caller];
            }
            else {
                var ret = CCTimerPluginCallbackSpec.create(this, caller);
                this.callbacks.push(ret);
                return ret;
            }
        };
        CCTimerPlugin.prototype.addListener = function (delay, repeat, caller, method, args, coverBefore) {
            caller = caller || null;
            var _a = this.findCallback(caller, method), idx1 = _a[0], idx2 = _a[1];
            if (idx1 >= 0) {
                // 监听对象存在
                if (idx2 >= 0) {
                    // 监听方法也存在
                    if (!coverBefore) {
                        // 不覆盖原来的
                        return;
                    }
                    else {
                        // 覆盖原来的
                        // 移除原来的回调
                        this.unschedule(this.callbacks[idx1].handlers[idx2].callback);
                        this.callbacks[idx1].removeAt(idx2);
                        this.addNewHandler(delay, repeat, idx1, method, args);
                    }
                }
                else {
                    // 方法不存在
                    this.addNewHandler(delay, repeat, caller, method, args);
                }
            }
            else {
                // 原来不存在
                this.addNewHandler(delay, repeat, caller, method, args);
            }
        };
        return CCTimerPlugin;
    }(rigger.AbsServicePlugin));
    ccPlugins.CCTimerPlugin = CCTimerPlugin;
})(ccPlugins || (ccPlugins = {}));
